#!/usr/bin/env bash

# Copyright (C) 2015, Arpinum
#
# Beastmaster is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Beastmaster is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# Beastmaster. If not, see http://www.gnu.org/licenses/lgpl.html.

# Beastmaster all in one source file


function bst_config__load() {
  BST__CONFIG_DIR="${HOME}/.bst"
  bst_config__ensure_config_file_exists
}

function bst_config__ensure_config_file_exists() {
  if [[ ! -f "$(bst_config__config_file)" ]]; then
    mkdir -p "${BST__CONFIG_DIR}"
    system__print_line "# project_name:/project/dir:tag1:tag2" > "$(bst_config__config_file)"
  fi
}

function bst_config__project_lines() {
  local line
  while read line; do
    bst_config__project_line_is_commented "${line}" || system__print_line "${line}"
  done < "$(bst_config__config_file)"
}

function bst_config__project_line_is_commented() {
  [[ "$1" == \#* ]]
}

function bst_config__config_file() {
  system__print "${BST__CONFIG_DIR}/config"
}


function system__print_line() {
  system__print "$1"
  system__print_new_line
}

function system__print() {
  printf "%s" "$1"
}

function system__print_new_line() {
  printf "\n"
}

function system__array_contains() {
  local value=$1
  shift 1
  local i
  for (( i=1; i <= $#; i++ )); do
    if [[ "${!i}" == "${value}" ]]; then
      return 0
    fi
  done
  return 1
}

function system__print_array() {
  local element
  for element in "$@"; do
    system__print_line "${element}"
  done
}


function command__run() {
  _command__parse_arguments "$@"
  _command__check_args_count $#
  $(_namespace)run_default "$@"
}

function _command__check_args_count() {
  local expected=$($(_namespace)arguments_count)
  (( $1 > ${expected} )) && _command__wrong_args_count $1 $expected
}

function _command__parse_arguments() {
  local argument
  for argument in "$@"; do
    case "${argument}" in
      -h|--help)
      command__help_triggered
      ;;
      -*|--*)
      _command__illegal_option_parsed "${argument}"
      ;;
      *)
      if $(_namespace)with_sub_commands; then
        _command__check_command "${argument}"
        shift 1
        $(_namespace)run_command "${argument}" "$@"
        exit 0
      fi
    esac
  done
}

function _command__check_command() {
  local accepted_commands=($($(_namespace)accepted_commands))
  system__array_contains "$1" "${accepted_commands[@]}"
  (( $? != 0 )) && _command__illegal_command_parsed "$1"
}

function command__help_triggered() {
  _command__print_usage
  exit 0
}

function _command__illegal_option_parsed() {
  local option="${1%=*}"
  option="${option#-}"
  option="${option#-}"
  system__print_line "$(_command__name): illegal option -- ${option}"
  system__print_new_line
  _command__print_usage
  exit 1
}

function _command__wrong_args_count() {
  system__print_line "$(_command__name): wrong args count -- $1 instead of $2"
  system__print_new_line
  _command__print_usage
  exit 1
}

function _command__illegal_command_parsed() {
  system__print_line "$(_command__name): illegal command -- $1"
  system__print_new_line
  _command__print_usage
  exit 1
}

function _command__print_usage() {
  system__print_line "$($(_namespace)usage)"
}

function _command__name() {
  [[ "${BST__CURRENT_COMMAND}" == "default" ]] \
    && system__print "bst" \
    || system__print "bst ${BST__CURRENT_COMMAND}"
}

function _namespace() {
  system__print "_bst_${BST__CURRENT_COMMAND}_command__"
}


function bst_project__name_from_line() {
  _bst_project__first_token "$1"
}

function bst_project__directory_from_line() {
  local without_name="$(_bst_project__without_first_token "$1")"
  _bst_project__first_token "${without_name}"
}

function bst_project__tags_from_line() {
  local without_name="$(_bst_project__without_first_token "$1")"
  local only_tags="$(_bst_project__without_first_token "${without_name}")"
  while [[ -n "${only_tags}" ]]; do
    _bst_project__first_token "${only_tags}"
    system__print_new_line
    only_tags="$(_bst_project__without_first_token "${only_tags}")"
  done
}

function _bst_project__first_token() {
  system__print "${1%%:*}"
}

function _bst_project__without_first_token() {
  [[ "$1" == *:* ]] && system__print "${1#*:}"
}


function bst_config_command__run() {
  BST__CURRENT_COMMAND="config"
  command__run "$@"
}

function _bst_config_command__with_sub_commands() {
  return 1
}

function _bst_config_command__arguments_count() {
  system__print "0"
}

function _bst_config_command__run_default() {
  _bst_config_command__check_editor
  "${EDITOR}" "$(bst_config__config_file)"
}

function _bst_config_command__check_editor() {
  if [[ -z "${EDITOR}" ]]; then
    system__print_line "EDITOR environment variable must be set."
    system__print_line "  ex: export EDITOR=/usr/bin/nano (or vi if you like 50 shades of grey)"
    exit 1
  fi
}

function _bst_config_command__usage() {
  system__print "\
Usage: bst config

Edit the configuration."
}


function bst_free_command__run() {
  BST__CURRENT_COMMAND="free"
  command__run "$@"
}

function _bst_free_command__with_sub_commands() {
  return 1
}

function _bst_free_command__arguments_count() {
  system__print "1"
}

function _bst_free_command__run_default() {
  local name="$1"
  local new_config="$(_bst_free_command__create_temp_file)"
  local line
  while read line; do
    _bst_free_command__line_must_be_kept "${line}" "${name}" && echo "${line}" >> "${new_config}"
  done < "$(bst_config__config_file)"
  _bst_free_command__copy_temp_file_in_config_file "${new_config}"
}

function _bst_free_command__line_must_be_kept() {
  local line="$1"
  local name="$2"
  bst_config__project_line_is_commented "${line}" && return 0
  local current_name="$(bst_project__name_from_line "${line}")"
  [[ "${current_name}" != "${name}" ]]
}

function _bst_free_command__create_temp_file() {
  local file="${BST__CONFIG_DIR}/config_${RANDOM}"
  touch "${file}"
  system__print "${file}"
}

function _bst_free_command__copy_temp_file_in_config_file() {
  local new_config="$1"
  cat "${new_config}" > "$(bst_config__config_file)"
  rm "${new_config}"
}

function _bst_free_command__usage() {
  system__print "\
Usage: bst free <project-name>

Remove a project from your project list."
}


function bst_list_command__run() {
  BST__CURRENT_COMMAND="list"
  command__run "$@"
}

function _bst_list_command__with_sub_commands() {
  return 1
}

function _bst_list_command__arguments_count() {
  system__print "0"
}

function _bst_list_command__run_default() {
  local line
  for line in $(bst_config__project_lines); do
    local name="$(bst_project__name_from_line "${line}")"
    local dir="$(bst_project__directory_from_line "${line}")"
    local tags="$(_bst_list_comand__tags_from_line "${line}")"
    system__print_line "${name} at ${dir}${tags}"
  done
}

function _bst_list_comand__tags_from_line() {
  local tags="$(bst_project__tags_from_line "$1")"
  for tag in ${tags[@]}; do
    system__print " #${tag}"
  done
}

function _bst_list_command__usage() {
  system__print "\
Usage: bst list

Print your project list."
}


function bst_order_command__run() {
  system__print_line "order with $@"
}


function bst_tame_command__run() {
  system__print_line "tame with $@"
}


function bst_program__run() {
  bst_config__load
  BST__CURRENT_COMMAND="default"
  command__run "$@"
}

function _bst_default_command__with_sub_commands() {
  return 0
}

function _bst_default_command__accepted_commands() {
  system__print_array "config" "free" "list" "order" "tame"
}

function _bst_default_command__run_default() {
  command__help_triggered
}

function _bst_default_command__run_command() {
  local command="$1"
  shift 1
  local command_function="bst_${command}_command__run"
  ${command_function} "$@"
}

function _bst_default_command__usage() {
  system__print "\
Usage: bst <command> [arg...]

A Bash tool which can run any command in your favorite projects (aka pets).

Options:
  -h, --help  Print usage

Commands:
  config  Edit the configuration
  free    Remove a project from your project list
  list    Print your project list
  order   Execute a command in the project directory
  tame    Add a project to your project list

Run 'bst <command> --help' for more information on a command."
}


[[ "$0" == "${BASH_SOURCE[0]}" ]] && bst_program__run "$@" || true