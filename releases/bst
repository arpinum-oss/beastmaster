#!/usr/bin/env bash

# Copyright (C) 2015, Arpinum
#
# Beastmaster is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# Beastmaster is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# Beastmaster. If not, see http://www.gnu.org/licenses/lgpl.html.

# Beastmaster all in one source file


bst_config__load() {
  BST_VALUE_SEPARATOR=","
  BST_CONFIG_DIR="${HOME}/.bst"
  _bst_config__ensure_config_file_exists
}

_bst_config__ensure_config_file_exists() {
  if [[ ! -f "$(bst_config__config_file)" ]]; then
    mkdir -p "${BST_CONFIG_DIR}"
    system__print_line "$(_bst_config__config_file_header)" > "$(bst_config__config_file)"
  fi
}

_bst_config__config_file_header() {
  system__print "\
#
# Beastmaster config file
#
# Declare one project per line, ex:
#
# name:directory:tag1:tag2:...:tagN
#"
}

bst_config__project_lines() {
  local line
  while read line; do
    bst_config__project_line_is_commented "${line}" || system__print_line "${line}"
  done < "$(bst_config__config_file)"
}

bst_config__project_line_is_commented() {
  [[ "$1" == \#* ]]
}

bst_config__config_file() {
  system__print "${BST_CONFIG_DIR}/config"
}



system__print_line() {
  system__print "$1"
  system__print_new_line
}

system__print() {
  printf "%s" "$1"
}

system__print_new_line() {
  printf "\n"
}

system__array_contains() {
  local value=$1
  shift 1
  local i
  for (( i=1; i <= $#; i++ )); do
    if [[ "${!i}" == "${value}" ]]; then
      return 0
    fi
  done
  return 1
}

system__print_array() {
  local element
  for element in "$@"; do
    system__print_line "${element}"
  done
}


token__at() {
  local position="$1"
  local string="$2"
  local i
  for (( i=1; i < ${position}; i++ )); do
    string="$(token__without_first "${string}")"
  done
  system__print "${string%%:*}"
}

token__without_first() {
  [[ "$1" == *:* ]] && system__print "${1#*:}"
}


option__name() {
  local option="${1%=*}"
  option="${option#-}"
  system__print "${option#-}"
}

option__value() {
  system__print "${1#*=}"
}

option__short_option_from_string() {
  token__at 1 "$1"
}

option__long_option_from_string() {
  token__at 2 "$1"
}

option__variable_from_string() {
  token__at 3 "$1"
}


command__parse_args() {
  bst_read_options=0
  _command__parse_arguments "$@"
  shift ${bst_read_options}
  $(_namespace)run "$@"
}

command__define_current_command() {
  bst_current_command="$1"
  bst_delegate_to_sub_commands="no"
  bst_option_strings=()
}

command__delegate_to_sub_commands() {
  bst_delegate_to_sub_commands="yes"
}

command__with_option() {
  bst_option_strings+=("$1")
}

command__check_args_count() {
  local expected=$1
  local actual=$2
  (( ${actual} > ${expected} )) && _command__wrong_args_count ${actual} ${expected}
}

_command__parse_arguments() {
  local argument
  for argument in "$@"; do
    case "${argument}" in
      -h|--help)
      command__help_triggered
      ;;
      --*)
      _command__handle_long_option "${argument}"
      ;;
      -*)
      _command__handle_short_option "${argument}"
      ;;
      *)
      [[ "${bst_delegate_to_sub_commands}" == "yes" ]] && return
      ;;
    esac
  done
}

command__help_triggered() {
  _command__print_usage
  exit 0
}

_command__handle_short_option() {
  _command__handle_option "$1" "short"
}

_command__handle_long_option() {
  _command__handle_option "$1" "long"
}

_command__handle_option() {
  local option_with_dash="$1"
  local option_length="$2"
  local option_name="$(option__name "${option_with_dash}")"
  local option_string
  for option_string in ${bst_option_strings[@]}; do
    if [[ "${option_name}" == "$(option__"${option_length}"_option_from_string "${option_string}")" ]]; then
      local option_variable="$(option__variable_from_string "${option_string}")"
      eval "${option_variable}"="$(option__value "${option_with_dash}")"
      ((bst_read_options++))
      return
    fi
  done
  _command__illegal_option_parsed "${option_name}"
}

_command__illegal_option_parsed() {
  system__print_line "$(_command__name): illegal option -- $1"
  system__print_new_line
  _command__print_usage
  exit 1
}

_command__wrong_args_count() {
  system__print_line "$(_command__name): wrong args count -- $1 instead of $2 at most"
  system__print_new_line
  _command__print_usage
  exit 1
}

command__illegal_command_parsed() {
  system__print_line "$(_command__name): illegal command -- $1"
  system__print_new_line
  _command__print_usage
  exit 1
}

_command__print_usage() {
  system__print_line "$($(_namespace)usage)"
}

_command__name() {
  [[ "${bst_current_command}" == "default" ]] \
    && system__print "bst" \
    || system__print "bst ${bst_current_command}"
}

_namespace() {
  system__print "_bst_${bst_current_command}_command__"
}


bst_project__name_from_line() {
  token__at 1 "$1"
}

bst_project__directory_from_line() {
  token__at 2 "$1"
}

bst_project__tags_from_line() {
  local without_name="$(token__without_first "$1")"
  local only_tags="$(token__without_first "${without_name}")"
  while [[ -n "${only_tags}" ]]; do
    token__at 1 "${only_tags}"
    system__print_new_line
    only_tags="$(token__without_first "${only_tags}")"
  done
}


bst_config_command__parse_args() {
  command__define_current_command "config"
  command__parse_args "$@"
}

_bst_config_command__run() {
  command__check_args_count 0 $#
  _bst_config_command__check_editor
  "${EDITOR}" "$(bst_config__config_file)"
}

_bst_config_command__check_editor() {
  if [[ -z "${EDITOR}" ]]; then
    system__print_line "EDITOR environment variable must be set."
    system__print_line "  ex: export EDITOR=/usr/bin/nano (or vi if you like 50 shades of grey)"
    exit 1
  fi
}

_bst_config_command__usage() {
  system__print "\
Usage: bst config

Edit the configuration."
}


bst_free_command__parse_args() {
  command__define_current_command "free"
  command__parse_args "$@"
}

_bst_free_command__run() {
  command__check_args_count 1 $#
  local name="$1"
  local new_config="$(_bst_free_command__create_temp_file)"
  local line
  while read line; do
    _bst_free_command__line_must_be_kept "${line}" "${name}" && system__print_line "${line}" >> "${new_config}"
  done < "$(bst_config__config_file)"
  _bst_free_command__copy_temp_file_in_config_file "${new_config}"
}

_bst_free_command__line_must_be_kept() {
  local line="$1"
  local name="$2"
  bst_config__project_line_is_commented "${line}" && return 0
  local current_name="$(bst_project__name_from_line "${line}")"
  [[ "${current_name}" != "${name}" ]]
}

_bst_free_command__create_temp_file() {
  local file="${BST_CONFIG_DIR}/config_${RANDOM}"
  touch "${file}"
  system__print "${file}"
}

_bst_free_command__copy_temp_file_in_config_file() {
  local new_config="$1"
  cat "${new_config}" > "$(bst_config__config_file)"
  rm "${new_config}"
}

_bst_free_command__usage() {
  system__print "\
Usage: bst free <project-name>

Remove a project from your project list."
}


bst_list_command__parse_args() {
  command__define_current_command "list"
  command__parse_args "$@"
}

_bst_list_command__run() {
  command__check_args_count 0 $#
  local line
  for line in $(bst_config__project_lines); do
    local name="$(bst_project__name_from_line "${line}")"
    local dir="$(bst_project__directory_from_line "${line}")"
    local tags="$(_bst_list_command__tags_from_line "${line}")"
    system__print_line "${name} at ${dir}${tags}"
  done
}

_bst_list_command__tags_from_line() {
  local tags="$(bst_project__tags_from_line "$1")"
  for tag in ${tags[@]}; do
    system__print " #${tag}"
  done
}

_bst_list_command__usage() {
  system__print "\
Usage: bst list

Print your project list."
}


bst_order_command__parse_args() {
  system__print_line "order with $@"
}


bst_tame_command__parse_args() {
  command__define_current_command "tame"
  command__with_option "t:tags:bst_taming_tags"
  command__parse_args "$@"
}

_bst_tame_command__run() {
  local directory="$(pwd)"
  if (( $# == 0 )); then
    _bst_tame_command__add_project "${directory##*\/}" "${directory}"
  else
    command__check_args_count 1 $#
    _bst_tame_command__add_project "$1" "${directory}"
  fi
}

_bst_tame_command__add_project() {
  local name="$1"
  local directory="$2"
  _bst_tame_command__check_project_collisions "${name}" "${directory}"
  local line="${name}:${directory}"
  line="$(_bst_tame_command__line_with_tags "${line}")"
  system__print_line "${line}" >> "$(bst_config__config_file)"
}

_bst_tame_command__line_with_tags() {
  local line="$1"
  local tag
  local tags=(${bst_taming_tags//${BST_VALUE_SEPARATOR}/ })
  for tag in ${tags[@]}; do
    line="${line}:${tag}"
  done
  system__print "${line}"
}

_bst_tame_command__check_project_collisions() {
  local name="$1"
  local directory="$2"
  local line
  for line in $(bst_config__project_lines); do
    local current_name="$(bst_project__name_from_line "${line}")"
    local current_dir="$(bst_project__directory_from_line "${line}")"
    [[ "${name}" == "${current_name}" ]] && _bst_tame_command__name_collision "${name}"
    [[ "${directory}" == "${current_dir}" ]] && _bst_tame_command__directory_collision "${directory}"
  done
}

_bst_tame_command__name_collision() {
  system__print_line "The project cannot be tamed: name $1 already exists."
  exit 1
}

_bst_tame_command__directory_collision() {
  system__print_line "The project cannot be tamed: directory $1 already exists."
  exit 1
}

_bst_tame_command__usage() {
  system__print "\
Usage: bst tame [project_name] [options]

Options:
  -t, --tags=tag1[,tag2][,tagN]   Assign one or more tags to the project
  -h, --help                      Print usage

Add a project to your project list."
}


bst_program__run() {
  bst_config__load
  command__define_current_command "default"
  command__delegate_to_sub_commands
  command__parse_args "$@"
}

_bst_default_command__run() {
  (( $# == 0 )) && command__help_triggered
  _bst_default_command__run_command "$@"
}

_bst_default_command__run_command() {
  local command="$1"
  local accepted=("config" "free" "list" "order" "tame")
  system__array_contains "${command}" "${accepted[@]}" || command__illegal_command_parsed "${command}"
  shift 1
  bst_${command}_command__parse_args "$@"
}

_bst_default_command__usage() {
  system__print "\
Usage: bst command [arg...]

A Bash tool which can run any command in your favorite projects (aka pets).

Options:
  -h, --help  Print usage

Commands:
  config      Edit the configuration
  free        Remove a project from your project list
  list        Print your project list
  order       Execute a command in the project directory
  tame        Add a project to your project list

Run 'bst command --help' for more information on a command."
}


[[ "$0" == "${BASH_SOURCE[0]}" ]] && bst_program__run "$@" || true